import { Injectable, Optional, NgZone, NgModule, defineInjectable, inject } from '@angular/core';
import { Subject, merge, fromEvent, from, interval, timer, of } from 'rxjs';
import { bufferTime, distinctUntilChanged, filter, finalize, map, scan, switchMap, take, takeUntil, tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UserIdleConfig = /** @class */ (function () {
    function UserIdleConfig() {
    }
    return UserIdleConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * User's idle service.
 */
var UserIdleService = /** @class */ (function () {
    function UserIdleService(config, _ngZone) {
        this._ngZone = _ngZone;
        this.timerStart$ = new Subject();
        this.timeout$ = new Subject();
        /**
         * Idle value in seconds.
         * Default equals to 10 minutes.
         */
        this.idle = 600;
        /**
         * Timeout value in seconds.
         * Default equals to 5 minutes.
         */
        this.timeout = 300;
        /**
         * Ping value in seconds.
         * * Default equals to 2 minutes.
         */
        this.ping = 120;
        if (config) {
            this.idle = config.idle;
            this.timeout = config.timeout;
            this.ping = config.ping;
        }
    }
    /**
     * Start watching for user idle and setup timer and ping.
     */
    /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    UserIdleService.prototype.startWatching = /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    function () {
        var _this = this;
        this.activityEvents$ = merge(fromEvent(window, 'mousemove'), fromEvent(window, 'resize'), fromEvent(document, 'keydown'));
        this.idle$ = from(this.activityEvents$);
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
        // If any of user events is not active for idle-seconds when start timer.
        this.idleSubscription = this.idle$
            .pipe(bufferTime(500), // Starting point of detecting of user's inactivity
        filter(function (arr) { return !arr.length && !_this.isIdleDetected && !_this.isInactivityTimer; }), tap(function () { return (_this.isIdleDetected = true); }), switchMap(function () {
            return _this._ngZone.runOutsideAngular(function () {
                return interval(1000).pipe(takeUntil(merge(_this.activityEvents$, timer(_this.idle * 1000).pipe(tap(function () {
                    _this.isInactivityTimer = true;
                    _this.timerStart$.next(true);
                })))), finalize(function () { return (_this.isIdleDetected = false); }));
            });
        }))
            .subscribe();
        this.setupTimer(this.timeout);
        this.setupPing(this.ping);
    };
    /**
     * @return {?}
     */
    UserIdleService.prototype.stopWatching = /**
     * @return {?}
     */
    function () {
        this.stopTimer();
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    UserIdleService.prototype.stopTimer = /**
     * @return {?}
     */
    function () {
        this.isInactivityTimer = false;
        this.timerStart$.next(false);
    };
    /**
     * @return {?}
     */
    UserIdleService.prototype.resetTimer = /**
     * @return {?}
     */
    function () {
        this.stopTimer();
        this.isTimeout = false;
    };
    /**
     * Return observable for timer's countdown number that emits after idle.
     */
    /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    UserIdleService.prototype.onTimerStart = /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    function () {
        var _this = this;
        return this.timerStart$.pipe(distinctUntilChanged(), switchMap(function (start) { return (start ? _this.timer$ : of(null)); }));
    };
    /**
     * Return observable for timeout is fired.
     */
    /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    UserIdleService.prototype.onTimeout = /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    function () {
        var _this = this;
        return this.timeout$.pipe(filter(function (timeout) { return !!timeout; }), tap(function () { return (_this.isTimeout = true); }), map(function () { return true; }));
    };
    /**
     * @return {?}
     */
    UserIdleService.prototype.getConfigValue = /**
     * @return {?}
     */
    function () {
        return {
            idle: this.idle,
            timeout: this.timeout,
            ping: this.ping
        };
    };
    /**
     * Set config values.
     * @param config
     */
    /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    UserIdleService.prototype.setConfigValues = /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    function (config) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set config values');
            return;
        }
        if (config.idle) {
            this.idle = config.idle;
        }
        if (config.ping) {
            this.ping = config.ping;
        }
        if (config.timeout) {
            this.timeout = config.timeout;
        }
    };
    /**
     * Set custom activity events
     *
     * @param customEvents Example: merge(
     *   fromEvent(window, 'mousemove'),
     *   fromEvent(window, 'resize'),
     *   fromEvent(document, 'keydown'),
     *   fromEvent(document, 'touchstart'),
     *   fromEvent(document, 'touchend')
     * )
     */
    /**
     * Set custom activity events
     *
     * @param {?} customEvents Example: merge(
     *   fromEvent(window, 'mousemove'),
     *   fromEvent(window, 'resize'),
     *   fromEvent(document, 'keydown'),
     *   fromEvent(document, 'touchstart'),
     *   fromEvent(document, 'touchend')
     * )
     * @return {?}
     */
    UserIdleService.prototype.setCustomActivityEvents = /**
     * Set custom activity events
     *
     * @param {?} customEvents Example: merge(
     *   fromEvent(window, 'mousemove'),
     *   fromEvent(window, 'resize'),
     *   fromEvent(document, 'keydown'),
     *   fromEvent(document, 'touchstart'),
     *   fromEvent(document, 'touchend')
     * )
     * @return {?}
     */
    function (customEvents) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set custom activity events');
            return;
        }
        this.activityEvents$ = customEvents;
    };
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @param timeout Timeout in seconds.
     */
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @protected
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    UserIdleService.prototype.setupTimer = /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @protected
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    function (timeout) {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            _this.timer$ = interval(1000).pipe(take(timeout), map(function () { return 1; }), scan(function (acc, n) { return acc + n; }), tap(function (count) {
                if (count === timeout) {
                    _this.timeout$.next(true);
                }
            }));
        });
    };
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @param ping
     */
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @protected
     * @param {?} ping
     * @return {?}
     */
    UserIdleService.prototype.setupPing = /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @protected
     * @param {?} ping
     * @return {?}
     */
    function (ping) {
        var _this = this;
        this.ping$ = interval(ping * 1000).pipe(filter(function () { return !_this.isTimeout; }));
    };
    UserIdleService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    UserIdleService.ctorParameters = function () { return [
        { type: UserIdleConfig, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    /** @nocollapse */ UserIdleService.ngInjectableDef = defineInjectable({ factory: function UserIdleService_Factory() { return new UserIdleService(inject(UserIdleConfig, 8), inject(NgZone)); }, token: UserIdleService, providedIn: "root" });
    return UserIdleService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UserIdleModule = /** @class */ (function () {
    function UserIdleModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    UserIdleModule.forRoot = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: UserIdleModule,
            providers: [
                { provide: UserIdleConfig, useValue: config }
            ]
        };
    };
    UserIdleModule.decorators = [
        { type: NgModule, args: [{
                    imports: []
                },] },
    ];
    return UserIdleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { UserIdleService, UserIdleConfig, UserIdleModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci11c2VyLWlkbGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcudHMiLCJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLXVzZXItaWRsZS9saWIvYW5ndWxhci11c2VyLWlkbGUubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBVc2VySWRsZUNvbmZpZyB7XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBpZGxlOiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBwaW5nOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlLFxuICBTdWJqZWN0LFxuICBTdWJzY3JpcHRpb24sXG4gIG1lcmdlLFxuICBmcm9tRXZlbnQsXG4gIGZyb20sXG4gIGludGVydmFsLFxuICB0aW1lcixcbiAgb2Zcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBidWZmZXJUaW1lLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgZmlsdGVyLFxuICBmaW5hbGl6ZSxcbiAgbWFwLFxuICBzY2FuLFxuICBzd2l0Y2hNYXAsXG4gIHRha2UsXG4gIHRha2VVbnRpbCxcbiAgdGFwXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFVzZXJJZGxlQ29uZmlnIH0gZnJvbSAnLi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcnO1xuXG4vKipcbiAqIFVzZXIncyBpZGxlIHNlcnZpY2UuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFVzZXJJZGxlU2VydmljZSB7XG4gIHBpbmckOiBPYnNlcnZhYmxlPGFueT47XG5cbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGNhbiBpbnRlcnJ1cHRzIHVzZXIncyBpbmFjdGl2aXR5IHRpbWVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFjdGl2aXR5RXZlbnRzJDogT2JzZXJ2YWJsZTxhbnk+O1xuXG4gIHByb3RlY3RlZCB0aW1lclN0YXJ0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCB0aW1lb3V0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCBpZGxlJDogT2JzZXJ2YWJsZTxhbnk+O1xuICBwcm90ZWN0ZWQgdGltZXIkOiBPYnNlcnZhYmxlPGFueT47XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqIERlZmF1bHQgZXF1YWxzIHRvIDEwIG1pbnV0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgaWRsZSA9IDYwMDtcbiAgLyoqXG4gICAqIFRpbWVvdXQgdmFsdWUgaW4gc2Vjb25kcy5cbiAgICogRGVmYXVsdCBlcXVhbHMgdG8gNSBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHRpbWVvdXQgPSAzMDA7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqICogRGVmYXVsdCBlcXVhbHMgdG8gMiBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHBpbmcgPSAxMjA7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHN0YXR1cy5cbiAgICovXG4gIHByb3RlY3RlZCBpc1RpbWVvdXQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaW1lciBvZiB1c2VyJ3MgaW5hY3Rpdml0eSBpcyBpbiBwcm9ncmVzcy5cbiAgICovXG4gIHByb3RlY3RlZCBpc0luYWN0aXZpdHlUaW1lcjogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIGlzSWRsZURldGVjdGVkOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBpZGxlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgY29uZmlnOiBVc2VySWRsZUNvbmZpZywgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB0aGlzLmlkbGUgPSBjb25maWcuaWRsZTtcbiAgICAgIHRoaXMudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuICAgICAgdGhpcy5waW5nID0gY29uZmlnLnBpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHdhdGNoaW5nIGZvciB1c2VyIGlkbGUgYW5kIHNldHVwIHRpbWVyIGFuZCBwaW5nLlxuICAgKi9cbiAgc3RhcnRXYXRjaGluZygpIHtcbiAgICB0aGlzLmFjdGl2aXR5RXZlbnRzJCA9IG1lcmdlKFxuICAgICAgZnJvbUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScpLFxuICAgICAgZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLFxuICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpXG4gICAgKTtcblxuICAgIHRoaXMuaWRsZSQgPSBmcm9tKHRoaXMuYWN0aXZpdHlFdmVudHMkKTtcblxuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaWRsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiB1c2VyIGV2ZW50cyBpcyBub3QgYWN0aXZlIGZvciBpZGxlLXNlY29uZHMgd2hlbiBzdGFydCB0aW1lci5cbiAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24gPSB0aGlzLmlkbGUkXG4gICAgICAucGlwZShcbiAgICAgICAgYnVmZmVyVGltZSg1MDApLCAvLyBTdGFydGluZyBwb2ludCBvZiBkZXRlY3Rpbmcgb2YgdXNlcidzIGluYWN0aXZpdHlcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIGFyciA9PiAhYXJyLmxlbmd0aCAmJiAhdGhpcy5pc0lkbGVEZXRlY3RlZCAmJiAhdGhpcy5pc0luYWN0aXZpdHlUaW1lclxuICAgICAgICApLFxuICAgICAgICB0YXAoKCkgPT4gKHRoaXMuaXNJZGxlRGV0ZWN0ZWQgPSB0cnVlKSksXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PlxuICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgaW50ZXJ2YWwoMTAwMCkucGlwZShcbiAgICAgICAgICAgICAgdGFrZVVudGlsKFxuICAgICAgICAgICAgICAgIG1lcmdlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cyQsXG4gICAgICAgICAgICAgICAgICB0aW1lcih0aGlzLmlkbGUgKiAxMDAwKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNJbmFjdGl2aXR5VGltZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXJTdGFydCQubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGZpbmFsaXplKCgpID0+ICh0aGlzLmlzSWRsZURldGVjdGVkID0gZmFsc2UpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgpO1xuXG4gICAgdGhpcy5zZXR1cFRpbWVyKHRoaXMudGltZW91dCk7XG4gICAgdGhpcy5zZXR1cFBpbmcodGhpcy5waW5nKTtcbiAgfVxuXG4gIHN0b3BXYXRjaGluZygpIHtcbiAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaWRsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BUaW1lcigpIHtcbiAgICB0aGlzLmlzSW5hY3Rpdml0eVRpbWVyID0gZmFsc2U7XG4gICAgdGhpcy50aW1lclN0YXJ0JC5uZXh0KGZhbHNlKTtcbiAgfVxuXG4gIHJlc2V0VGltZXIoKSB7XG4gICAgdGhpcy5zdG9wVGltZXIoKTtcbiAgICB0aGlzLmlzVGltZW91dCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBvYnNlcnZhYmxlIGZvciB0aW1lcidzIGNvdW50ZG93biBudW1iZXIgdGhhdCBlbWl0cyBhZnRlciBpZGxlLlxuICAgKi9cbiAgb25UaW1lclN0YXJ0KCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMudGltZXJTdGFydCQucGlwZShcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBzd2l0Y2hNYXAoc3RhcnQgPT4gKHN0YXJ0ID8gdGhpcy50aW1lciQgOiBvZihudWxsKSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gb2JzZXJ2YWJsZSBmb3IgdGltZW91dCBpcyBmaXJlZC5cbiAgICovXG4gIG9uVGltZW91dCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy50aW1lb3V0JC5waXBlKFxuICAgICAgZmlsdGVyKHRpbWVvdXQgPT4gISF0aW1lb3V0KSxcbiAgICAgIHRhcCgoKSA9PiAodGhpcy5pc1RpbWVvdXQgPSB0cnVlKSksXG4gICAgICBtYXAoKCkgPT4gdHJ1ZSlcbiAgICApO1xuICB9XG5cbiAgZ2V0Q29uZmlnVmFsdWUoKTogVXNlcklkbGVDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICBpZGxlOiB0aGlzLmlkbGUsXG4gICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICBwaW5nOiB0aGlzLnBpbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb25maWcgdmFsdWVzLlxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqL1xuICBzZXRDb25maWdWYWx1ZXMoY29uZmlnOiBVc2VySWRsZUNvbmZpZykge1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24gJiYgIXRoaXMuaWRsZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbGwgc3RvcFdhdGNoaW5nKCkgYmVmb3JlIHNldCBjb25maWcgdmFsdWVzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5pZGxlKSB7XG4gICAgICB0aGlzLmlkbGUgPSBjb25maWcuaWRsZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5waW5nKSB7XG4gICAgICB0aGlzLnBpbmcgPSBjb25maWcucGluZztcbiAgICB9XG4gICAgaWYgKGNvbmZpZy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGN1c3RvbSBhY3Rpdml0eSBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIGN1c3RvbUV2ZW50cyBFeGFtcGxlOiBtZXJnZShcbiAgICogICBmcm9tRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJyksXG4gICAqICAgZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLFxuICAgKiAgIGZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKSxcbiAgICogICBmcm9tRXZlbnQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0JyksXG4gICAqICAgZnJvbUV2ZW50KGRvY3VtZW50LCAndG91Y2hlbmQnKVxuICAgKiApXG4gICAqL1xuICBzZXRDdXN0b21BY3Rpdml0eUV2ZW50cyhjdXN0b21FdmVudHM6IE9ic2VydmFibGU8YW55Pikge1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24gJiYgIXRoaXMuaWRsZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbGwgc3RvcFdhdGNoaW5nKCkgYmVmb3JlIHNldCBjdXN0b20gYWN0aXZpdHkgZXZlbnRzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpdml0eUV2ZW50cyQgPSBjdXN0b21FdmVudHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgdGltZXIuXG4gICAqXG4gICAqIENvdW50cyBldmVyeSBzZWNvbmRzIGFuZCByZXR1cm4gbisxIGFuZCBmaXJlIHRpbWVvdXQgZm9yIGxhc3QgY291bnQuXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHByb3RlY3RlZCBzZXR1cFRpbWVyKHRpbWVvdXQ6IG51bWJlcikge1xuICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLnRpbWVyJCA9IGludGVydmFsKDEwMDApLnBpcGUoXG4gICAgICAgIHRha2UodGltZW91dCksXG4gICAgICAgIG1hcCgoKSA9PiAxKSxcbiAgICAgICAgc2NhbigoYWNjLCBuKSA9PiBhY2MgKyBuKSxcbiAgICAgICAgdGFwKGNvdW50ID0+IHtcbiAgICAgICAgICBpZiAoY291bnQgPT09IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCQubmV4dCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHBpbmcuXG4gICAqXG4gICAqIFBpbmdzIGV2ZXJ5IHBpbmctc2Vjb25kcyBvbmx5IGlmIGlzIG5vdCB0aW1lb3V0LlxuICAgKiBAcGFyYW0gcGluZ1xuICAgKi9cbiAgcHJvdGVjdGVkIHNldHVwUGluZyhwaW5nOiBudW1iZXIpIHtcbiAgICB0aGlzLnBpbmckID0gaW50ZXJ2YWwocGluZyAqIDEwMDApLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLmlzVGltZW91dCkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXNlcklkbGVDb25maWcgfSBmcm9tICcuL2FuZ3VsYXItdXNlci1pZGxlLmNvbmZpZyc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIFVzZXJJZGxlTW9kdWxlIHtcbiAgc3RhdGljIGZvclJvb3QoY29uZmlnOiBVc2VySWRsZUNvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogVXNlcklkbGVNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IFVzZXJJZGxlQ29uZmlnLCB1c2VWYWx1ZTogY29uZmlnfVxuICAgICAgXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0lBQUE7S0FhQztJQUFELHFCQUFDO0NBQUE7Ozs7OztBQ2JEOzs7QUE2QkE7SUEwQ0UseUJBQXdCLE1BQXNCLEVBQVUsT0FBZTtRQUFmLFlBQU8sR0FBUCxPQUFPLENBQVE7UUEvQjdELGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUNyQyxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQzs7Ozs7UUFPbEMsU0FBSSxHQUFHLEdBQUcsQ0FBQzs7Ozs7UUFLWCxZQUFPLEdBQUcsR0FBRyxDQUFDOzs7OztRQUtkLFNBQUksR0FBRyxHQUFHLENBQUM7UUFjbkIsSUFBSSxNQUFNLEVBQUU7WUFDVixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDeEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBQzlCLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztTQUN6QjtLQUNGOzs7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